(()=>{"use strict";
    var e;
    var t;
    var n = require("@popmotion/easing");
    var r = require("framesync");
    var i = require("lodash.throttle");
    var o = require("popmotion");

    function s(e){return e?e.default:e}e=module.exports,t=()=>u,Object.defineProperty(e,"wrapGrid",{get:t,set:undefined,enumerable:!0,configurable:!0});const a={anticipate:n.anticipate,backIn:n.backIn,backInOut:n.backInOut,backOut:n.backOut,circIn:n.circIn,circInOut:n.circInOut,circOut:n.circOut,easeIn:n.easeIn,easeInOut:n.easeInOut,easeOut:n.easeOut,linear:n.linear},c="animateGridId",l=(e, t)=>{const{top:n,left:r,width:i,height:o}=t.getBoundingClientRect(),s={top:n,left:r,width:i,height:o};return s.top-=e.top,s.left-=e.left,s.top=Math.max(s.top,0),s.left=Math.max(s.left,0),s},d=(e, {translateX:t,translateY:n,scaleX:i,scaleY:o}, {immediate:a}={})=>{const c=0===t&&0===n&&1===i&&1===o,l=()=>{e.style.transform=c?"":`translateX(${t}px) translateY(${n}px) scaleX(${i}) scaleY(${o})`};a?l():s(r).render(l);const d=e.children[0];if(d){const e=()=>{d.style.transform=c?"":`scaleX(${1/i}) scaleY(${1/o})`};a?e():s(r).render(e)}},u=(e, {duration:t=250,stagger:n=0,easing:u="easeInOut",onStart:f=()=>{},onEnd:h=()=>{}}={})=>{if(!a[u])throw new Error(`${u} is not a valid easing name`);let m=!1;const p={},g= t=>{const n=e.getBoundingClientRect();Array.from(t).forEach((e=>{if("function"!=typeof e.getBoundingClientRect)return;if(!e.dataset[c]){const t=`${Math.random()}`;e.dataset[c]=t}const t=e.dataset[c];p[t]||(p[t]={});const r=l(n,e);p[t].rect=r,p[t].gridBoundingClientRect=n}))};g(e.children);const w=s(i)((()=>{const t=document.querySelector("body"),n=t&&!t.contains(e);e&&!n||window.removeEventListener("resize",w),g(e.children)}),250);window.addEventListener("resize",w);const b=s(i)((()=>{g(e.children)}),20);e.addEventListener("scroll",b);const O= i=>{if("forceGridAnimation"!==i){if(!i.filter((e=>"class"===e.attributeName||e.addedNodes.length||e.removedNodes.length)).length)return;if(m)return}const w=e.getBoundingClientRect(),b=Array.from(e.children);b.filter((e=>{const t=p[e.dataset[c]];if(t&&t.stopTween)return t.stopTween(),delete t.stopTween,!0})).forEach((e=>{e.style.transform="";const t=e.children[0];t&&(t.style.transform="")}));const O=b.map((e=>({childCoords:{},el:e,boundingClientRect:l(w,e)}))).filter((({el:e,boundingClientRect:t})=>{const n=p[e.dataset[c]];return n?t.top!==n.rect.top||t.left!==n.rect.left||t.width!==n.rect.width||t.height!==n.rect.height:(g([e]),!1)}));if(O.forEach((({el:e})=>{if(Array.from(e.children).length>1)throw new Error("Make sure every grid item has a single container element surrounding its children")})),!O.length)return;const y=O.map((({el:e})=>e));m=!0,f(y),setTimeout((()=>{m=!1}),0);const v=[];O.map((e=>{const t=e.el.children[0];return t&&(e.childCoords=l(w,t)),e})).forEach((({el:e,boundingClientRect:{top:i,left:l,width:f,height:h},childCoords:{top:m,left:w}}, b)=>{const O=e.children[0],y=p[e.dataset[c]],I={scaleX:y.rect.width/f,scaleY:y.rect.height/h,translateX:y.rect.left-l,translateY:y.rect.top-i};let E;e.style.transformOrigin="0 0",O&&w===l&&m===i&&(O.style.transformOrigin="0 0");const C=new Promise((e=>{E=e}));v.push(C),d(e,I,{immediate:!0});const R=()=>{const{stop:n}=(0,o.tween)({from:I,to:{translateX:0,translateY:0,scaleX:1,scaleY:1},duration:t,ease:a[u]}).start({update: t=>{d(e,t),s(r).postRender((()=>g([e])))},complete:E});y.stopTween=n};if("number"!=typeof n)R();else{const e=setTimeout((()=>{s(r).update(R)}),n*b);y.stopTween=()=>clearTimeout(e)}})),Promise.all(v).then((()=>{h(y)}))},y=new MutationObserver(O);return y.observe(e,{childList:!0,attributes:!0,subtree:!0,attributeFilter:["class"]}),{unwrapGrid:()=>{window.removeEventListener("resize",w),e.removeEventListener("scroll",b),y.disconnect()},forceGridAnimation:()=>O("forceGridAnimation")}}})();